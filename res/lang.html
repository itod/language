<h3>Booleans</h3>

<p>An object of type boolean can have one of two values, <code>true</code> and <code>false</code>.</p>

<p>An <code>or</code> expression is evaluated by evaluating each operand and converting its value to a boolean as if by a call to the <code><a href="#fn-Boolean">Boolean</a></code> function. The result is true if either value is true and false otherwise. The right operand is not evaluated if the left operand evaluates to true.</p>

<p>An <code>and</code> expression is evaluated by evaluating each operand and converting its value to a boolean as if by a call to the <code><a href="#fn-Boolean">Boolean</a></code> function. The result is true if both values are true and false otherwise. The right operand is not evaluated if the left operand evaluates to false.</p>

<p>An EqualityExpr (that is not just a RelationalExpr) or a RelationalExpr (that is not just an AdditiveExpr) is evaluated by comparing the objects that result from evaluating the two operands.</p>

<p>When the operator is <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code> or <code>&gt;</code>, then the objects are compared by converting both objects to numbers and comparing the numbers according to IEEE 754. The <code>&lt;</code> comparison will be true if and only if the first number is less than the second number. The <code>&lt;=</code> comparison will be true if and only if the first number is less than or equal to the second number. The <code>&gt;</code> comparison will be true if and only if the first number is greater than the second number. The <code>&gt;=</code> comparison will be true if and only if the first number is greater than or equal to the second number.</p>


<h2>Numbers</h2>

<p>A number represents a floating-point number. A number can have any double-precision 64-bit format IEEE 754 value. These include a special "Not-a-Number" (NaN) value, positive and negative infinity, and positive and negative zero. See Section 4.2.3 of [JLS] for a summary of the key rules of the IEEE 754 standard.</p>

<p>The numeric operators convert their operands to numbers as if by calling the <code><a href="#fn-Number">Number</a></code> function.</p>

<p>The <code>+</code> operator performs addition.</p>

<p>The <code>-</code> operator performs subtraction.</p>

<p>The <code>/</code> operator performs floating-point division according to IEEE 754.</p>

<p>The % operator returns the remainder from a truncating division. For example,</p>

<p><code>5 mod 2</code> returns <code>1</code></p>
<p><code>5 mod -2</code> returns <code>1</code></p>
<p><code>-5 mod 2</code> returns <code>-1</code></p>
<p><code>-5 mod -2</code> returns <code>-1</code></p>

<p>NOTE: This is the same as the % operator in Java and ECMAScript.</p>
<p>NOTE: This is not the same as the IEEE 754 remainder operation, which returns the remainder from a rounding division.</p>

<h3>Strings</h3>

<p>Strings consist of a sequence of zero or more characters, where a character is defined as in the XML Recommendation [XML]. A single character in XPath thus corresponds to a single Unicode abstract character with a single corresponding Unicode scalar value (see [Unicode]); this is not the same thing as a 16-bit Unicode code value: the Unicode coded character representation for an abstract character with Unicode scalar value greater that U+FFFF is a pair of 16-bit Unicode code values (a surrogate pair). In many programming languages, a string is represented by a sequence of 16-bit Unicode code values; implementations of XPath in such languages must take care to ensure that a surrogate pair is correctly treated as a single XPath character.</p>

